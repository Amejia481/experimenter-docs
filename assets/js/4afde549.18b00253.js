(self.webpackChunkexperimenter_docs=self.webpackChunkexperimenter_docs||[]).push([[565],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return m},kt:function(){return d}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,h=u["".concat(l,".").concat(d)]||u[d]||p[d]||r;return n?i.createElement(h,o(o({ref:t},m),{},{components:n})):i.createElement(h,o({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1206:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return c},default:function(){return p}});var i=n(2122),a=n(9756),r=(n(7294),n(3905)),o={id:"bucketing",title:"Bucketing",slug:"/Bucketing"},s=void 0,l={unversionedId:"data-scientists/bucketing",id:"data-scientists/bucketing",isDocsHomePage:!1,title:"Bucketing",description:"Bucketing is the process of randomly assigning users to experiment branches. When a user is \u201cbucketed\u201d into an experiment, it means that the configuration in one of its branches (such as a change to part of the UI) can be activated, and that any interactions we record from that moment on can be associated with the experiment and branch identifier.",source:"@site/docs/data-scientists/bucketing.md",sourceDirName:"data-scientists",slug:"/Bucketing",permalink:"/Bucketing",editUrl:"https://github.com/mozilla/experimenter-docs/edit/main/docs/data-scientists/bucketing.md",tags:[],version:"current",frontMatter:{id:"bucketing",title:"Bucketing",slug:"/Bucketing"},sidebar:"sidebar",previous:{title:"Telemetry for Experiments",permalink:"/telemetry"},next:{title:"Implementing an experiment",permalink:"/fenix-engineers"}},c=[{value:"Assumptions",id:"assumptions",children:[]},{value:"Implementation",id:"implementation",children:[{value:"Configuration",id:"configuration",children:[]},{value:"Randomization Unit",id:"randomization-unit",children:[]},{value:"Experiment assignment",id:"experiment-assignment",children:[]},{value:"Branch assignment",id:"branch-assignment",children:[]},{value:"Controlling interactions",id:"controlling-interactions",children:[]}]},{value:"Validating bucketing",id:"validating-bucketing",children:[{value:"Branch balance",id:"branch-balance",children:[]}]}],m={toc:c};function p(e){var t=e.components,o=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,i.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Bucketing")," is the process of randomly assigning users to experiment branches. When a user is \u201cbucketed\u201d into an experiment, it means that the configuration in one of its branches (such as a change to part of the UI) can be activated, and that any interactions we record from that moment on can be associated with the experiment and branch identifier."),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"which experiments?")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},'This documentation applies to experiments launched to Desktop, iOS, and Android Firefox through the "Nimbus" or "Normandy" systems. Differences between platforms are noted when relevant.'))),(0,r.kt)("h2",{id:"assumptions"},"Assumptions"),(0,r.kt)("p",null,"In order to support the analysis of controlled experiments, we must be able to satisfy the following functional requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We can randomly assign users to one or more branches of of an experiment."),(0,r.kt)("li",{parentName:"ul"},"A single user can enroll in multiple experiments simultaneously."),(0,r.kt)("li",{parentName:"ul"},"We can specify certain characteristics about a client that must be met for a client to bucket into an experiment, such as region."),(0,r.kt)("li",{parentName:"ul"},"We can assign users to unevenly distributed branches(e.g. 10% to A, 90% to B)"),(0,r.kt)("li",{parentName:"ul"},"We can control interactions between experiments (i.e. ensure experiments do not overlap) when we want to."),(0,r.kt)("li",{parentName:"ul"},"We can observe which users have bucketed into which experiments/branches and when.")),(0,r.kt)("p",null,"We assume the following statistical requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Assignment of targeted clients to branches is uniformly random with respect to all observables. If we were to look at the set of users for each branch (where unique users are identified by the randomization unit), we should see roughly the same distribution of locale, location, profile age, etc."),(0,r.kt)("li",{parentName:"ul"},"Branch assignment must not depend on anything the user can influence."),(0,r.kt)("li",{parentName:"ul"},"Actual enrollment is probabilistically equal to the percentage of total traffic allocated to that branch. e.g. If we configured an experiment with two equal branches to enroll 10% of the population, we should see 5% of the total population enroll in each branch."),(0,r.kt)("li",{parentName:"ul"},"Enrollment in a branch is deterministic. Given the same experiment configuration, interaction rules, and user identifier, the result should always be the same. Shipping a new experiment must not change the basis for assigning a client to a branch."),(0,r.kt)("li",{parentName:"ul"},"Enrollment in a branch is persistent. Once a user is bucketed into a branch, they should continue to see the same branch for the duration of the experiment."),(0,r.kt)("li",{parentName:"ul"},"We should be able to control undesired interactions between experiments based on the specific requirements of our system. For example, as a first step, we can\u2019t enroll users in more than one branch that contains configuration for the same feature.")),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"At a high level, we bucket users into experiments client-side by taking a hash of a ",(0,r.kt)("a",{parentName:"p",href:"#randomization-unit"},"randomly generated user id")," and some configuration delivered from our experimentation servers. Assignment happens when configuration is synced to the client and sends enrollment telemetry."),(0,r.kt)("h3",{id:"configuration"},"Configuration"),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"This example uses the Nimbus experiment format. While the Normandy format is different, the client-side algorithm is almost identical. Many fields have been omitted for brevity."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "my-cool-test",\n  "targeting": "browserSettings.update.channel == \'release\'",\n  "bucketConfig": {\n    "start": 5000,\n    "count": 2000,\n    "total": 10000,\n    "namespace": "aboutwelcome-1",\n    "randomizationUnit": "normandy_id"\n  },\n\n  "branches": [\n    { "slug": "control", "ratio": 1 },\n    { "slug": "treatment", "ratio": 1 }\n  ]\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"targeting")," specifies conditions that must be met before the client can be considered. In this case, the user must in the release channel (beta or nightly users will not be considered)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"count")," is a fraction of ",(0,r.kt)("inlineCode",{parentName:"li"},"total")," representing the chance of getting bucketed. In this case, the chance is 20%."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"start"),' is an integer representing a "range" of buckets, which allows for ',(0,r.kt)("a",{parentName:"li",href:"#controlling-interactions"},"isolation of experiments")," along a single ",(0,r.kt)("inlineCode",{parentName:"li"},"namespace"),". In this example, the start is set to 5000, which would isolate it from users in an existing experiment with a ",(0,r.kt)("inlineCode",{parentName:"li"},"start")," of 0 and a ",(0,r.kt)("inlineCode",{parentName:"li"},"count")," of 5000.")),(0,r.kt)("h3",{id:"randomization-unit"},"Randomization Unit"),(0,r.kt)("p",null,"Bucketing uses a stable unique identifier generated at startup. Note that this identifier is ",(0,r.kt)("em",{parentName:"p"},"not")," ",(0,r.kt)("inlineCode",{parentName:"p"},"client_id"),", which is the standard unit for aggregation for most data analysis in Firefox."),(0,r.kt)("p",null,"Desktop experiments use the ",(0,r.kt)("inlineCode",{parentName:"p"},"normandy_id"),", a unique stable identifier generated by the ",(0,r.kt)("inlineCode",{parentName:"p"},"ClientEnvironment")," module during first run and stored in a preference (see ",(0,r.kt)("a",{parentName:"p",href:"https://searchfox.org/mozilla-central/source/toolkit/components/utils/ClientEnvironment.jsm#99"},"implementation"),"). It differs from ",(0,r.kt)("inlineCode",{parentName:"p"},"client_id")," in that it is ",(0,r.kt)("em",{parentName:"p"},"not")," exposed to Telemetry and it is not synced across profiles / accounts."),(0,r.kt)("p",null,"Mobile experiments use the ",(0,r.kt)("inlineCode",{parentName:"p"},"nimbus_id"),", a unique identifier generated by the Nimbus client during first run stored in the experiments database (see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mozilla/application-services/blob/866c72cddc4d925a0dc1a83c9aeebd2e878be85e/components/nimbus/src/lib.rs#L433"},"implementation"),")."),(0,r.kt)("h3",{id:"experiment-assignment"},"Experiment assignment"),(0,r.kt)("p",null,"In order to randomize clients into experiments, we take a SHA-256 hash of the ",(0,r.kt)("inlineCode",{parentName:"p"},"namespace")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"randomization_unit")," truncated to 12 characters and check if that falls between the bucket range configured in the experiment."),(0,r.kt)("p",null,"Consider this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "experiment-B",\n  "bucketConfig": {\n    "start": 3000,\n    "count": 2000,\n    "total": 10000,\n    "namespace": "rutabaga",\n    "randomizationUnit": "normandy_id"\n  }\n}\n')),(0,r.kt)("p",null,"A client will be bucketed into the experiment if the input hash falls in the range ",(0,r.kt)("inlineCode",{parentName:"p"},"3000")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"4999"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"                  start\n                  |     hash\n                  v     v\n  [0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000]\n                              ^\n                              end\n")),(0,r.kt)("h3",{id:"branch-assignment"},"Branch assignment"),(0,r.kt)("p",null,"Assuming a client has satisfied all targeting conditions and bucketed into an experiment, we will randomly assign a branch. Unlike experiments, branches cannot specify targeting conditions, and hashes are re-randomized for every experiment. We do this by:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Assigning buckets equal to the ratios specified in each branch"),(0,r.kt)("li",{parentName:"ol"},"Taking a SHA-256 hash of the ",(0,r.kt)("a",{parentName:"li",href:"#randomization-unit"},"randomization unit")," and the experiment identifier (which is unique per experiment)"),(0,r.kt)("li",{parentName:"ol"},"Checking which range the input hash falls into")),(0,r.kt)("p",null,"For example, given the following branch ratios:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "experiment-123",\n  "branches": [\n    { "slug": "a", "ratio": 2 },\n    { "slug": "b", "ratio": 5 },\n    { "slug": "c", "ratio": 3 }\n  ]\n}\n')),(0,r.kt)("p",null,"We will assign 20% of the buckets to branch ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", 50% to ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),", and 30% to ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),". We take a hash of the client's ",(0,r.kt)("inlineCode",{parentName:"p"},"normandy_id")," and the experiment slug (",(0,r.kt)("inlineCode",{parentName:"p"},"experiment-123"),") and see which bucket range it falls into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"                     hash\n                     v\n  [a, a, b, b, b, b, b, c, c, c]\n\n")),(0,r.kt)("h3",{id:"controlling-interactions"},"Controlling interactions"),(0,r.kt)("p",null,"By default, all experiments are allowed to interact and clients can bucket into multiple experiments simultaneously. However, sometimes we ",(0,r.kt)("em",{parentName:"p"},"do")," want experiments to be exclusive, such as when they change the same set of variables."),(0,r.kt)("p",null,"In practice, we have three methods of preventing interactions between experiments:"),(0,r.kt)("h4",{id:"bucket-range-exclusion"},"Bucket range exclusion"),(0,r.kt)("p",null,"Experiments that configure the same namespace will bucket identically for the same user identifier. This means we can exclude experiments by giving the same namespace and have them specify non-interacting ranges (start / count)."),(0,r.kt)("p",null,"Consider two experiments with the following configurations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "experiment-A",\n  "bucketConfig": {\n    "start": 0,\n    "count": 3000,\n    "total": 10000,\n    "namespace": "rutabaga",\n    "randomizationUnit": "normandy_id"\n  }\n},\n{\n  "slug": "experiment-B",\n  "bucketConfig": {\n    "start": 3000,\n    "count": 2000,\n    "total": 10000,\n    "namespace": "rutabaga",\n    "randomizationUnit": "normandy_id"\n  }\n}\n')),(0,r.kt)("p",null,"Say we generate a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"4562")," from our hash on a given client. The client is bucketed into ",(0,r.kt)("inlineCode",{parentName:"p"},"experiment-B")," because this falls in the the range for this experiment (which is ",(0,r.kt)("inlineCode",{parentName:"p"},"3000")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"4999"),")."),(0,r.kt)("p",null,"Note that we ",(0,r.kt)("em",{parentName:"p"},"always")," re-randomize branch assignment, so we can't isolate based on branch."),(0,r.kt)("h4",{id:"client-side-rules"},"Client-side rules"),(0,r.kt)("p",null,"In Nimbus, clients are prevented from enrolling into two experiments that target the same feature with a simple check during enrollment. For example, a user cannot be enrolled in two experiments that change the ",(0,r.kt)("inlineCode",{parentName:"p"},"aboutwelcome")," feature."),(0,r.kt)("p",null,"In Normandy, clients are prevented from enrolling in two experiments that change the same preference."),(0,r.kt)("h4",{id:"targeting-exclusion"},"Targeting exclusion"),(0,r.kt)("p",null,"For specific experiments that should be excluded from others, a targeting expression can be included with a specific experiment identifier:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "targeting": "!activeExperiments[\'some-experiment\']"\n}\n')),(0,r.kt)("h2",{id:"validating-bucketing"},"Validating bucketing"),(0,r.kt)("h3",{id:"branch-balance"},"Branch balance"),(0,r.kt)("p",null,"We expect to see some variation between the observed v.s. expected ratios for enrollment in branches for experiments. However, too much imbalance might be indication that there might be a problem with the validity of the experiment configuration, implementation, or execution."),(0,r.kt)("p",null,"As a first step, we continuously monitor daily active population and enrollment by branch to see if anything is obviously wrong. We do this with standard Grafana monitoring dashboards generated for every experiment:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Daily active population is 2.152m control, 2.150m treatment",src:n(6794).Z})),(0,r.kt)("p",null,"We can also run a chi-squared test of independence to determine whether the difference between the actual v.s. expected ratio of branches is statistically significant. Note that this can have some temporary fluctuation, but if we see a sustained period of enrollment for which the p-value is less than 0.05, we consider it cause for further investigation."))}p.isMDXComponent=!0},6794:function(e,t,n){"use strict";t.Z=n.p+"assets/images/daily-active-pop-9bcc0e9ed1bd86a28cc050f233810fac.png"}}]);